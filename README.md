# Multithreaded application - solution of the remote control system in partial derivatives

## Постановка задачи
> Выбрать задачу и проработать реализацию алгоритма, допускающего раcпараллеливание на несколько потоков / процессов.
>
> Разработать тесты для проверки корректности алгоритма (входные данные, выходные данные, код для сравнения результатов). Для подготовки наборов
> тестов можно использовать математические пакеты, например, matlab (есть в классе СКЦ).
> Реализовать алгоритмы на java.
> Провести исследование эффекта от использования многоядерности / многопоточности / многопроцессности.
> Подготовить отчет в электронном виде.
> Варианты реализации (выбрать один):
> - java threads + synchronized blocks/methods;
> - java locks collection (Lock, Mutex, etc);
> - Futures.
## Реализация программы
Данная программ реализована на основе двух классов:
1. _CalcEquation_ - хранит информацию о дифференциальном уравнении и его параметрах.

   Этот класс позволяет определить и хранить параметры дифференциального уравнения, которые затем можно использовать для численного решения этого
   уравнения с заданными начальными условиями и шагом.
2. _CalcVector_ - используется для представления векторов, над которыми выполняются различные операции в методах при помощи параллеливания операций.

   Одним из таких примеров является метод _addVectorNumber_, производящий распараллеливание операций сложения каждого элемента вектора v с заданным
   значением val. Операция сложения выполняется параллельно в нескольких потоках благодаря использованию пула исполнителей и массива futures, что может
   ускорить вычисления, особенно при больших векторах и многих элементах.

## Параметры распараллеливания
В данной реализации параметр THREADS определяет количество потоков, которые будут использоваться для выполнения параллельных вычислений.
Он передается в методы класса _CalcVector_, который инициализирует ExecutorServicee, созданный с помощью Executors.newFixedThreadPool(THREADS), где THREADS - 
это количество потоков, которые будут использоваться для параллельных операций.

Каждая операция выполняется в отдельном потоке, и ее результат помещается в соответствующий элемент массива futures.

Внутри цикла итерируется по элементам вектора, и каждая операция выполняется параллельно для элементов вектора.
Для обеспечения корректности параллельных операций используется переменная finalI, чтобы создать "захватывающую финальную переменную". Это необходимо, чтобы 
гарантировать, что каждый поток получит правильное значение finalI.

После выполнения всех параллельных операций, пул исполнителей ExecutorService закрывается с помощью exec.shutdown(), что предотвращает добавление новых задач и 
завершает работу всех потоков после выполнения текущих задач.
## Исследование использования многопоточности
Исследование использования многопоточности проводилось при фиксированном значении параметра THREADS = 4.

| N потоков      | T работы алгоритма |
| ---------------| ------------------ |
| 4              | 726                |
| 10             | 492                |
| 16             | 412                |
| 20             | 462                |
| 64             | 492                |
| 256            | 1262               |
| 1023           | 4643               |

Вызывает внимание, что время выполнения существенно сокращается при распараллеливании алгоритма, но, по достижении 16 потоков, этот прирост эффективности 
перестает проявляться.

Заметное увеличение времени выполнения при увеличении количества потоков от 256 до 1024 может объясняться тем, что каждый поток имеет свои собственные 
накладные расходы. Эти расходы включают в себя процессы создания и управления потоками, а также расходы на синхронизацию и координацию между потоками. По мере 
увеличения числа потоков, эти накладные расходы могут начать доминировать, влияя на общее время выполнения алгоритма.
